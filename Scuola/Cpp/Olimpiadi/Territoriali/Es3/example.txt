[3, 1, 1, 1, 1]  <----- 4 (color to add)

no [3, 4]


si [4, 1, 1, 1]


3 + 1 == 4   start = 0, end = 1

there is no 'bigger_min_color'


min(3, 1) = 1

check sum of colors at the left and rigth of '1'

from start to end

while (true)
	right++
	left++

	if (right < end
		right_elements++
		right_sum += v[right]	
	if (left >= 0)
		left_elements++
		left_sum += v[left]



when rigth_sum 


-------------------------------
[3, 4, 7] <---- 4


1°   [1, 4, 2, 7]

2°   [3, 1, 4, 7]

add also   4  and  8:

1°:

	1.1	4, 1, 2, 7
	
	1.2	1, 4, 2, 7

	1.5	1, 1, 4, 1, 7

	1.3	1, 4, 1, 4, 4

	1.4	1, 4, 2, 4, 3

	1.4	1, 4, 2, 3, 4

----------------------------

v = [1, 4, 2, 7, 3, 6, 3]


add 7



1, 4, 2:   start = 0    end = 2


min is 1








4, 2, 7: start = 1  end = 3


min is 2


1.0  6, 7


1.1  4, 1, 6, 2

..................................................................................

step 1:

get how much i have to subract from the colors on left and right


crete a left and right index


check if the color from which we subtracted is at position '0' or at the 'end'


check also if the rest is == 0, than just place the color_to_add at position 'min_position'

____________________________________________________________________________________________
step 2:

while (left_side_index >= && right_side_index < v.size())


	get the new rest of the color at right and left


	if (rest == 0) replace and break !

	
better:

function that goes to the left and to the right


left:
	return the position where the while stoped, if the 'rest' is >= '0'

	else return -1;


	the save the position to compare it with the right

right: same


______________________________________________________________________


step 3:


position_of_min - left 

right - position_of_min


find the smallest between these 2 so there are more colors on the opposite side


if 1 < 2:
	delete the colors beween the min_position and where the right index stopped	
	place the color in min_position + 1

else
	do the opposite of the 'if'


